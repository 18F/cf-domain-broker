package gravel

import (
	"context"
	"crypto/tls"
	"crypto/x509"
	"fmt"
	"log"
	"net"
	"net/http"
	"os"
	"strconv"
	"testing"
	"time"

	"github.com/jmhodges/clock"
	"github.com/letsencrypt/pebble/ca"
	"github.com/letsencrypt/pebble/db"
	"github.com/letsencrypt/pebble/va"
	"github.com/letsencrypt/pebble/wfe"
	"github.com/miekg/dns"
	"github.com/spf13/afero"
)

// these are self-signed with `cfssl` from cloudflare. it would be better if they could be autogenerated at call time,
// but alas, I'm super lazy.
const (
	cert = `-----BEGIN CERTIFICATE-----
MIID6DCCAtCgAwIBAgIUd4vuozdDqFbj8Jj5PRh9BNNb8G4wDQYJKoZIhvcNAQEL
BQAwcDELMAkGA1UEBhMCVVMxETAPBgNVBAgTCENvbG9yYWRvMRAwDgYDVQQHEwdC
b3VsZGVyMSgwJgYDVQQKEx9HZW5lcmFsIFNlcnZpY2VzIEFkbWluaXN0cmF0aW9u
MRIwEAYDVQQLEwljbG91ZC5nb3YwHhcNMTkwNjEyMjEyMDAwWhcNMjAwNjExMjEy
MDAwWjBwMQswCQYDVQQGEwJVUzERMA8GA1UECBMIQ29sb3JhZG8xEDAOBgNVBAcT
B0JvdWxkZXIxKDAmBgNVBAoTH0dlbmVyYWwgU2VydmljZXMgQWRtaW5pc3RyYXRp
b24xEjAQBgNVBAsTCWNsb3VkLmdvdjCCASIwDQYJKoZIhvcNAQEBBQADggEPADCC
AQoCggEBAN2tFEll5g9HUU6bWhLWBIGd3kzxdgyLhbtRLBl4CyCD4DETNBMciFS3
jwLgt2kfTrbYiwLtJ5A2NzGIm+yzPXIEcwReaxMUROl9/WLAuyUJW7Z5jd6qKzwh
x7W3fc7Ix8j5nC0ZMFxoo0m4ly9p1PZ38mwz5NnYtfrlELpTE4eO6LDGTg5paW3B
3dmTNcNHB0iMXQ6f4bdJSiuyz/WXtHvUizBmSHbibkos6n8rgkj+FGfC3jHxK9IV
6XlPLaZDm8jDy221DZfdX7q2/RkwywoRLePzERN5M2r9BKdD5Btu2TkH8NLWUSgN
Pi6lDs8BVEw03lteTxEuG3M85IMH1r8CAwEAAaN6MHgwDgYDVR0PAQH/BAQDAgWg
MB0GA1UdJQQWMBQGCCsGAQUFBwMBBggrBgEFBQcDAjAMBgNVHRMBAf8EAjAAMB0G
A1UdDgQWBBTj92LGyGPOeFNd1yS7+qwmoIqUvDAaBgNVHREEEzARgglsb2NhbGhv
c3SHBH8AAAEwDQYJKoZIhvcNAQELBQADggEBAEdmQPUMyaLl9cGwOosbODACtKc6
z0dr9Q43p/XvzxAhwBMikZ0AyxJluKNXSwre9daOpmU763TyndSzpCrJunPa65s2
foURuJy5zWpDR242o8FpDX2IR0196POqaSc5/N08/UViwhLuY8W4K2XApLEXbRZi
1Z5kAhv6kpyV/E7Nk+Wy33u1I3rye5ZTILgB+m8eKkmzEegNl5ke6jLHUTUg5Kfy
Ynxiv3CBzAUJCy4bNgh1ZxeXOJtIH2A0JsxsbgsuqEDAYL1kORIXGFIO9nttgAOT
fBUcJFoVv56oYUHnazv/yxwh/EZi0585fSp/eKU7acB981+LqPwtVjCP5GQ=
-----END CERTIFICATE-----`
	key = `-----BEGIN RSA PRIVATE KEY-----
MIIEpQIBAAKCAQEA3a0USWXmD0dRTptaEtYEgZ3eTPF2DIuFu1EsGXgLIIPgMRM0
ExyIVLePAuC3aR9OttiLAu0nkDY3MYib7LM9cgRzBF5rExRE6X39YsC7JQlbtnmN
3qorPCHHtbd9zsjHyPmcLRkwXGijSbiXL2nU9nfybDPk2di1+uUQulMTh47osMZO
DmlpbcHd2ZM1w0cHSIxdDp/ht0lKK7LP9Ze0e9SLMGZIduJuSizqfyuCSP4UZ8Le
MfEr0hXpeU8tpkObyMPLbbUNl91furb9GTDLChEt4/MRE3kzav0Ep0PkG27ZOQfw
0tZRKA0+LqUOzwFUTDTeW15PES4bczzkgwfWvwIDAQABAoIBAQClgctKvcTWFXZU
TVMkCxyUNe0633E3DpjLcWCOp30PSscBfQf9WOlE70PcbzEhUJmxlN29UpmeZ4wv
9IIOaQjwbvf9BA3H0fNdrY6Yw7M2hNUv2XOeEsly/Pmh6B0LXgckO5FqbosYA5we
t65RXR/+4TFjrh8os0+zwoEJzGshYqI8t7aMmEakuYhLw63OEdukwbBJzzFItAK9
afZSQuV4AJKtyXaVQgIh1EUrYnLhSHv94hwQ43iV61O2u/Tagof3eb/miiiiTRdS
A/Da0SGgRX+Kjmmsl6JYcHG4Bn3YqaSbspXtfrLJ/s3X9oOUUOWVtvWcdblfvIYk
xUTI/cOBAoGBAN7ELs0oQeyMfq8bx2fqIh2yUxFhbSiGEow991v/Rh7cEeBnMK50
Ym4s12ooAQ3CDkoE+4jtpR92cR7rfULgYhwoEdc5V4HzwkWzKgqSTrKPQWBq/Jvd
Yic3iFr69nwYTQ5bbEPHdPhMXl217wwGRo30yK/OJn/SQ9/Q3PDyk3N/AoGBAP6/
Qg4wX9FmjF2eBe6p6wClR4P8A3gCUws/f0xofgvT9AVaTxgxcpV8JhnIPnSHS7fU
7pfbnYF8nC/OSI6McDM/b7d2D8CIX4v76IgeDsn/8N/J+RlG7gUPIyOgDFqjiG9R
HF2r6UpJ/Q1V/uii2+HqWJI2Ca5fIMfqHfrjNDzBAoGBANI2p0OKPcuPOOzddeql
ktQbNzArk+qtuksFHqt91RnB6kysk8/MnCYDwrO2VGg7O2i2Evc/6pYqGs1mw6mc
PHj9hvhmcCF9eVJ0o7OeJQ1zCeqGiyI6YylGyjGwqXCpLe3ib+P2EHdO+a3MxWu/
cEz9NXRRQRtVvB805YmqH2LZAoGBAKIoMq7/ge60XUM2VMZgKPQnQUe1gqvApwXw
7GJB3YI/8AP8QX6/8xVOip48xey9NqiVBS9rH26OWIlhwPPkV4N3rPBWWZ6P8GoV
9yW2JGnW3ohFc6fwa5CS2yZROav0juN0+R5zULP2NvtnMzT4fgjneGvRtAXoDeDT
mTPbrqPBAoGARHcRaCdmqf7Ua1VbzZmbXCCPML52nag4oi3OUrlz0RDPJN9r6x7u
w2d9JR7F8WeYvCWOJYfiv+s95+uO/nR4ugup+ePLYBjSnfe1a9/fmNs3uifgBZZS
cpec7QABY4S+7oHBDUGWM7/IybgICwXUMRNhZmZShWZtiWwt+bmD2oU=
-----END RSA PRIVATE KEY-----`
	root = `-----BEGIN CERTIFICATE-----
MIIDwTCCAqmgAwIBAgIUKMKenfqizRR8tW/uXGDVp69WBF0wDQYJKoZIhvcNAQEL
BQAwcDELMAkGA1UEBhMCVVMxETAPBgNVBAgTCENvbG9yYWRvMRAwDgYDVQQHEwdC
b3VsZGVyMSgwJgYDVQQKEx9HZW5lcmFsIFNlcnZpY2VzIEFkbWluaXN0cmF0aW9u
MRIwEAYDVQQLEwljbG91ZC5nb3YwHhcNMTkwNjEyMjExNzAwWhcNMjQwNjEwMjEx
NzAwWjBwMQswCQYDVQQGEwJVUzERMA8GA1UECBMIQ29sb3JhZG8xEDAOBgNVBAcT
B0JvdWxkZXIxKDAmBgNVBAoTH0dlbmVyYWwgU2VydmljZXMgQWRtaW5pc3RyYXRp
b24xEjAQBgNVBAsTCWNsb3VkLmdvdjCCASIwDQYJKoZIhvcNAQEBBQADggEPADCC
AQoCggEBAME0sV7fhzk4fP5hZ83qEZ/hjzrcfLQu+svxcVJQF82tt0zbeYoq7fWN
M2SYQSN17mTo4GjFvTbf1S4ruk2soFStivN2UDUnWF1wuVlTRv98NpIECQub9qLF
Z8rCzGn6lCPz6SmjPa91rX2Wg+MqNiOiSFT/zxb/x3iQ0YWHXllAFngGeoh7bG+4
J28JxiVZzpuxvPsqTxgOI9QTIN9eHSS6iP5JPcrUXSzzGQHWfBkGkSbkiPKOy1UX
8eGceF+ur2PAn4DDlDEFcLbAvqBcHbN+I0wieai8S10M1buoO04yWvDuJlPhWzEC
r3/KmnzPl0bxF+bONR7jeUq4zwWgOXcCAwEAAaNTMFEwDgYDVR0PAQH/BAQDAgEG
MA8GA1UdEwEB/wQFMAMBAf8wHQYDVR0OBBYEFBqyn/XTpWS0Pxdp/9vbYHUC2rwg
MA8GA1UdEQQIMAaHBH8AAAEwDQYJKoZIhvcNAQELBQADggEBAAjah2fgEjIm2Anh
WpILX0TbqBjc8M3/19SQtLq3HMAOoPEU9JHRgZS3xWUGAwVlMtyQFODEA84g3l01
gDQAjhsyiRVW7dmhJ7iYm7noUMWOBBEWDZCJm0b3pYOgyz7Klb5Zgg51xpxwYwQl
Yr32ZTUPffSHYR2qIEzSm6d9Sr12dVUtVK/ix3m3ICyWO9xM2aDJTmyQwv7hloPz
RcpqZp1hrBL34ory67lpZcat6KyqAT6Dl9g3daPltCYyJl2Y2in/kBw3OhmYNY9P
ksflfXBW37Y2/AbW4yWyeuFbI2B1VsxhBeU8qmOETvDeWxQq0B9D4V7XHuUIvZsC
EeYVPIk=
-----END CERTIFICATE-----`
)

type GravelHarness struct {
	Server        http.Server
	PublicKey     []byte
	PrivateKey    []byte
	CA            []byte
	HttpPort      int
	HttpsPort     int
	ListenAddress string
	DnsPort       int
	TestRecords   map[string]string
	Client        *http.Client

	t      *testing.T
	logger *log.Logger
	fs     afero.Fs
	clk    clock.Clock
}

func NewGravelHarness(t *testing.T) *GravelHarness {
	gh := &GravelHarness{
		fs:            afero.NewMemMapFs(),
		t:             t,
		logger:        log.New(os.Stdout, "", 0),
		clk:           clock.New(),
		HttpPort:      5001,
		HttpsPort:     5002,
		ListenAddress: "localhost:14000",
		DnsPort:       5353,
		TestRecords:   make(map[string]string),
		PublicKey:     []byte(cert),
		PrivateKey:    []byte(key),
		CA:            []byte(root),
	}

	// build the DNS server and wait for it to boot.
	t.Log("booting dns server")
	go gh.buildDnsTestServer()
	time.Sleep(time.Second * 1)
	t.Log("dns server booted")

	// set our default resolver to be localhost:DnsPort so we can respond to DNS queries.
	net.DefaultResolver = &net.Resolver{
		PreferGo: true,
		Dial: func(ctx context.Context, _, _ string) (net.Conn, error) {
			d := net.Dialer{}
			return d.DialContext(ctx, "udp", fmt.Sprintf("localhost:%d", gh.DnsPort))
		},
	}

	// start pebble and wait for it to boot.
	t.Log("booting pebble")
	go gh.startPebble()
	time.Sleep(time.Second * 3)
	t.Log("pebble booted")

	// add our certs into the client pool.
	rootCAs, _ := x509.SystemCertPool()
	if rootCAs == nil {
		rootCAs = x509.NewCertPool()
	}
	if ok := rootCAs.AppendCertsFromPEM(gh.CA); !ok {
		t.Log("no certs appended, using system certs only")
	}

	tlsConf := &tls.Config{
		InsecureSkipVerify: true,
		RootCAs:            rootCAs,
	}

	gh.Client = &http.Client{
		Transport: &http.Transport{
			Proxy: http.ProxyFromEnvironment,
			DialContext: (&net.Dialer{
				Timeout:   30 * time.Second,
				KeepAlive: 30 * time.Second,
			}).DialContext,
			TLSHandshakeTimeout:   15 * time.Second,
			ResponseHeaderTimeout: 15 * time.Second,
			ExpectContinueTimeout: 1 * time.Second,
			TLSClientConfig: tlsConf,
		},
	}

	return gh
}

// startPebble will start the Pebble ACME server so we can have a local LE integration testing environment.
func (g *GravelHarness) startPebble() {
	var err error

	localDb := db.NewMemoryStore(g.clk)
	localCa := ca.New(g.logger, localDb)
	localVa := va.New(g.logger, g.clk, g.HttpPort, g.HttpsPort, false)

	wfeImpl := wfe.New(g.logger, g.clk, localDb, localVa, localCa, false)
	muxHandler := wfeImpl.Handler()

	tconf := &tls.Config{}
	tconf.Certificates = make([]tls.Certificate, 1)
	tconf.Certificates[0], err = tls.X509KeyPair(g.PublicKey, g.PrivateKey)
	if err != nil {
		g.t.Error(err)
	}

	g.Server = http.Server{
		Addr:      g.ListenAddress,
		TLSConfig: tconf,
		Handler:   muxHandler,
	}

	g.logger.Printf("Listening on: %s\n", g.ListenAddress)
	g.logger.Printf("ACME directory available at: https://%s%s", g.ListenAddress, wfe.DirectoryPath)
	g.logger.Printf("Root CA certificate available at: https://%s%s", g.ListenAddress, wfe.RootCertPath)

	err = g.Server.ListenAndServeTLS("", "")
	if err != nil {
		g.t.Error(err, "expected pebble to start and run without errors")
		g.t.FailNow()
	}
}

func (g *GravelHarness) buildDnsTestServer() {
	// attach request handler func
	dns.HandleFunc("service.", g.handleDnsRequest)

	// start server
	port := 5353
	server := &dns.Server{Addr: ":" + strconv.Itoa(port), Net: "udp"}
	g.t.Logf("starting dns at %d\n", port)
	err := server.ListenAndServe()
	defer server.Shutdown()
	if err != nil {
		g.t.Errorf("failed to start dns server: %s\n ", err.Error())
		g.t.FailNow()
	}
}

func (g *GravelHarness) parseQuery(m *dns.Msg) {
	for _, q := range m.Question {
		switch q.Qtype {
		case dns.TypeTXT:
			txt := g.TestRecords[q.Name]
			if txt != "" {
				rr, _ := dns.NewRR(txt)
				m.Answer = append(m.Answer, rr)
			}
		}
	}
}

func (g *GravelHarness) handleDnsRequest(w dns.ResponseWriter, r *dns.Msg) {
	m := new(dns.Msg)
	m.SetReply(r)
	m.Compress = false

	switch r.Opcode {
	case dns.OpcodeQuery:
		g.parseQuery(m)
	}

	w.WriteMsg(m)
}
